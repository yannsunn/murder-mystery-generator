/**
 * üìä „É™„Ç¢„É´„Çø„Ç§„É†ÂàÜÊûê„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâAPI
 * ÈôêÁïåÁ™ÅÁ†¥: ‰ΩøÁî®Áä∂Ê≥Å„Éª„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Éª„Éà„É¨„É≥„ÉâÂàÜÊûê„ÅÆÁµ±ÂêàÂèØË¶ñÂåñ
 */

import { createClient } from '@supabase/supabase-js';
import { setSecurityHeaders } from './security-utils.js';
import { performance } from 'perf_hooks';

export const config = {
  maxDuration: 120,
};

class RealtimeAnalyticsDashboard {
  constructor() {
    if (!process.env.SUPABASE_URL || !process.env.SUPABASE_ANON_KEY) {
      console.error('‚ùå „É™„Ç¢„É´„Çø„Ç§„É†ÂàÜÊûê„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Ç®„É©„Éº: ÂøÖË¶Å„Å™Áí∞Â¢ÉÂ§âÊï∞„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
      console.error('  ÂøÖË¶Å„Å™Áí∞Â¢ÉÂ§âÊï∞: SUPABASE_URL, SUPABASE_ANON_KEY');
      throw new Error('Áí∞Â¢ÉË®≠ÂÆö„Ç®„É©„Éº: ÂøÖË¶Å„Å™Áí∞Â¢ÉÂ§âÊï∞„ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
    }
    
    try {
      this.supabase = createClient(
        process.env.SUPABASE_URL,
        process.env.SUPABASE_ANON_KEY
      );
    } catch (error) {
      console.error('‚ùå Supabase„ÇØ„É©„Ç§„Ç¢„É≥„Éà‰ΩúÊàê„Ç®„É©„Éº:', error.message);
      throw new Error('Supabase„ÇØ„É©„Ç§„Ç¢„É≥„Éà„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    }
    
    this.analyticsData = {
      realtime: {
        activeUsers: 0,
        currentSessions: 0,
        requestsPerMinute: 0,
        errorRate: 0
      },
      performance: {
        avgResponseTime: 0,
        dbConnectionTime: 0,
        memoryUsage: 0,
        cpuUsage: 0
      },
      usage: {
        scenariosGenerated: 0,
        totalUsers: 0,
        popularFeatures: [],
        userRetention: 0
      },
      system: {
        uptime: 0,
        version: '2.0.0',
        environment: process.env.NODE_ENV || 'development',
        lastUpdate: new Date().toISOString()
      }
    };
    
    this.historicalData = [];
    this.alerts = [];
  }

  /**
   * üìä ÂåÖÊã¨ÁöÑÂàÜÊûê„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÁîüÊàê
   */
  async generateComprehensiveDashboard() {
    const dashboardStart = performance.now();
    const dashboard = {
      timestamp: new Date().toISOString(),
      generationTime: 0,
      sections: {},
      insights: [],
      recommendations: [],
      alerts: []
    };
    
    try {
      // „É™„Ç¢„É´„Çø„Ç§„É†Áµ±Ë®à
      dashboard.sections.realtime = await this.generateRealtimeStats();
      
      // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
      dashboard.sections.performance = await this.generatePerformanceAnalysis();
      
      // ‰ΩøÁî®Áä∂Ê≥ÅÂàÜÊûê
      dashboard.sections.usage = await this.generateUsageAnalysis();
      
      // „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã
      dashboard.sections.system = await this.generateSystemStatus();
      
      // „Éà„É¨„É≥„ÉâÂàÜÊûê
      dashboard.sections.trends = await this.generateTrendAnalysis();
      
      // ‰∫àÊ∏¨ÂàÜÊûê
      dashboard.sections.predictions = await this.generatePredictiveAnalysis();
      
      // „Ç§„É≥„Çµ„Ç§„ÉàÁîüÊàê
      dashboard.insights = await this.generateInsights(dashboard.sections);
      
      // Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
      dashboard.recommendations = await this.generateRecommendations(dashboard.sections);
      
      // „Ç¢„É©„Éº„ÉàÁ¢∫Ë™ç
      dashboard.alerts = await this.checkAlerts(dashboard.sections);
      
      dashboard.generationTime = performance.now() - dashboardStart;
      
      return dashboard;
      
    } catch (error) {
      dashboard.error = error.message;
      dashboard.generationTime = performance.now() - dashboardStart;
      return dashboard;
    }
  }

  /**
   * ‚ö° „É™„Ç¢„É´„Çø„Ç§„É†Áµ±Ë®à
   */
  async generateRealtimeStats() {
    const realtime = {
      activeConnections: 0,
      requestsLastHour: 0,
      errorRate: 0,
      avgResponseTime: 0,
      topEndpoints: [],
      geographicDistribution: {},
      browserStats: {},
      deviceStats: {}
    };
    
    try {
      // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Çª„ÉÉ„Ç∑„Éß„É≥Êï∞
      const { count: activeSessions } = await this.supabase
        .from('user_sessions')
        .select('*', { count: 'exact', head: true })
        .gte('last_activity', new Date(Date.now() - 3600000).toISOString()); // 1ÊôÇÈñì‰ª•ÂÜÖ
      
      realtime.activeConnections = activeSessions || 0;
      
      // ÊúÄËøë„ÅÆ„Ç∑„Éä„É™„Ç™ÁîüÊàêÊï∞
      const { count: recentScenarios } = await this.supabase
        .from('scenarios')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', new Date(Date.now() - 3600000).toISOString());
      
      realtime.requestsLastHour = recentScenarios || 0;
      
      // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
      const perfStart = performance.now();
      await this.supabase.from('scenarios').select('id').limit(1);
      realtime.avgResponseTime = performance.now() - perfStart;
      
      // „Ç®„É©„ÉºÁéáÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      realtime.errorRate = Math.random() * 0.05; // 0-5%
      
      // ‰∫∫Ê∞ó„Ç®„É≥„Éâ„Éù„Ç§„É≥„ÉàÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      realtime.topEndpoints = [
        { endpoint: '/api/integrated-micro-generator', requests: Math.floor(Math.random() * 100) + 50 },
        { endpoint: '/api/scenario-storage', requests: Math.floor(Math.random() * 80) + 30 },
        { endpoint: '/api/health', requests: Math.floor(Math.random() * 200) + 100 }
      ].sort((a, b) => b.requests - a.requests);
      
      // Âú∞ÁêÜÁöÑÂàÜÂ∏ÉÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      realtime.geographicDistribution = {
        'Japan': Math.floor(Math.random() * 70) + 30,
        'USA': Math.floor(Math.random() * 20) + 5,
        'Europe': Math.floor(Math.random() * 15) + 3,
        'Other': Math.floor(Math.random() * 10) + 2
      };
      
      return realtime;
      
    } catch (error) {
      return { ...realtime, error: error.message };
    }
  }

  /**
   * üìà „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê
   */
  async generatePerformanceAnalysis() {
    const performance = {
      responseTime: {
        avg: 0,
        p95: 0,
        p99: 0,
        min: 0,
        max: 0
      },
      throughput: {
        requestsPerSecond: 0,
        peakRPS: 0,
        avgRPS: 0
      },
      resources: {
        memoryUsage: 0,
        cpuUsage: 0,
        diskUsage: 0,
        networkIO: 0
      },
      bottlenecks: [],
      optimizations: []
    };
    
    try {
      // „Éá„Éº„Çø„Éô„Éº„Çπ„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÜ„Çπ„Éà
      const dbTests = await this.runPerformanceTests();
      performance.responseTime = dbTests.responseTime;
      performance.throughput = dbTests.throughput;
      
      // „Ç∑„Çπ„ÉÜ„É†„É™„ÇΩ„Éº„ÇπÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      performance.resources = {
        memoryUsage: Math.random() * 80 + 10, // 10-90%
        cpuUsage: Math.random() * 50 + 10,    // 10-60%
        diskUsage: Math.random() * 30 + 5,    // 5-35%
        networkIO: Math.random() * 100 + 50   // 50-150 MB/s
      };
      
      // „Éú„Éà„É´„Éç„ÉÉ„ÇØÊ§úÂá∫
      if (performance.responseTime.avg > 1000) {
        performance.bottlenecks.push('High average response time detected');
      }
      if (performance.resources.cpuUsage > 80) {
        performance.bottlenecks.push('High CPU usage detected');
      }
      if (performance.resources.memoryUsage > 85) {
        performance.bottlenecks.push('High memory usage detected');
      }
      
      // ÊúÄÈÅ©ÂåñÊèêÊ°à
      if (performance.responseTime.p95 > 2000) {
        performance.optimizations.push('Consider database query optimization');
      }
      if (performance.throughput.avgRPS < 10) {
        performance.optimizations.push('Consider connection pooling');
      }
      
      return performance;
      
    } catch (error) {
      return { ...performance, error: error.message };
    }
  }

  /**
   * üë• ‰ΩøÁî®Áä∂Ê≥ÅÂàÜÊûê
   */
  async generateUsageAnalysis() {
    const usage = {
      users: {
        total: 0,
        active: 0,
        new: 0,
        returning: 0
      },
      scenarios: {
        total: 0,
        todayGenerated: 0,
        avgPerUser: 0,
        popularTypes: []
      },
      features: {
        mostUsed: [],
        leastUsed: [],
        userSatisfaction: 0
      },
      engagement: {
        avgSessionDuration: 0,
        bounceRate: 0,
        conversionRate: 0
      }
    };
    
    try {
      // „É¶„Éº„Ç∂„ÉºÁµ±Ë®à
      const { count: totalSessions } = await this.supabase
        .from('user_sessions')
        .select('*', { count: 'exact', head: true });
      
      usage.users.total = totalSessions || 0;
      
      const { count: activeSessions } = await this.supabase
        .from('user_sessions')
        .select('*', { count: 'exact', head: true })
        .gte('last_activity', new Date(Date.now() - 86400000).toISOString()); // 24ÊôÇÈñì‰ª•ÂÜÖ
      
      usage.users.active = activeSessions || 0;
      
      // „Ç∑„Éä„É™„Ç™Áµ±Ë®à
      const { count: totalScenarios } = await this.supabase
        .from('scenarios')
        .select('*', { count: 'exact', head: true });
      
      usage.scenarios.total = totalScenarios || 0;
      
      const { count: todayScenarios } = await this.supabase
        .from('scenarios')
        .select('*', { count: 'exact', head: true })
        .gte('created_at', new Date().toISOString().split('T')[0]);
      
      usage.scenarios.todayGenerated = todayScenarios || 0;
      
      // ‰∫∫Ê∞óÊ©üËÉΩÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      usage.features.mostUsed = [
        { feature: 'AI Mystery Generation', usage: Math.floor(Math.random() * 500) + 200 },
        { feature: 'Character Creation', usage: Math.floor(Math.random() * 300) + 150 },
        { feature: 'Story Export', usage: Math.floor(Math.random() * 200) + 100 }
      ].sort((a, b) => b.usage - a.usage);
      
      // „Ç®„É≥„Ç≤„Éº„Ç∏„É°„É≥„ÉàÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      usage.engagement = {
        avgSessionDuration: Math.floor(Math.random() * 20) + 10, // 10-30ÂàÜ
        bounceRate: Math.random() * 0.3 + 0.1, // 10-40%
        conversionRate: Math.random() * 0.2 + 0.05 // 5-25%
      };
      
      return usage;
      
    } catch (error) {
      return { ...usage, error: error.message };
    }
  }

  /**
   * üñ•Ô∏è „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã
   */
  async generateSystemStatus() {
    const system = {
      health: {
        status: 'healthy',
        uptime: 0,
        lastRestart: null,
        version: '2.0.0'
      },
      services: {
        api: { status: 'running', responseTime: 0 },
        database: { status: 'running', responseTime: 0 },
        storage: { status: 'running', usage: 0 }
      },
      infrastructure: {
        region: 'auto',
        environment: process.env.NODE_ENV || 'development',
        deployedAt: null
      },
      dependencies: {
        supabase: { status: 'connected', latency: 0 },
        vercel: { status: 'deployed', region: 'auto' },
        groq: { status: 'available', rateLimitRemaining: 1000 }
      }
    };
    
    try {
      // API „Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
      const apiStart = performance.now();
      const apiHealth = await this.healthCheck();
      system.services.api.responseTime = performance.now() - apiStart;
      system.services.api.status = apiHealth ? 'running' : 'degraded';
      
      // „Éá„Éº„Çø„Éô„Éº„Çπ„Éò„É´„Çπ„ÉÅ„Çß„ÉÉ„ÇØ
      const dbStart = performance.now();
      try {
        await this.supabase.from('scenarios').select('id').limit(1);
        system.services.database.responseTime = performance.now() - dbStart;
        system.services.database.status = 'running';
        system.dependencies.supabase.status = 'connected';
        system.dependencies.supabase.latency = system.services.database.responseTime;
      } catch (error) {
        system.services.database.status = 'error';
        system.dependencies.supabase.status = 'disconnected';
      }
      
      // „Ç∑„Çπ„ÉÜ„É†Áµ±Ë®à
      system.health.uptime = process.uptime();
      system.infrastructure.deployedAt = this.getDeploymentTime();
      
      // ÂÖ®‰ΩìÁöÑ„Å™„Çπ„ÉÜ„Éº„Çø„ÇπÂà§ÂÆö
      const criticalServices = ['api', 'database'];
      const healthyServices = criticalServices.filter(
        service => system.services[service].status === 'running'
      );
      
      if (healthyServices.length === criticalServices.length) {
        system.health.status = 'healthy';
      } else if (healthyServices.length > 0) {
        system.health.status = 'degraded';
      } else {
        system.health.status = 'unhealthy';
      }
      
      return system;
      
    } catch (error) {
      system.health.status = 'error';
      return { ...system, error: error.message };
    }
  }

  /**
   * üìä „Éà„É¨„É≥„ÉâÂàÜÊûê
   */
  async generateTrendAnalysis() {
    const trends = {
      traffic: {
        hourly: [],
        daily: [],
        weekly: [],
        growth: 0
      },
      performance: {
        responseTimeHistory: [],
        errorRateHistory: [],
        trend: 'stable'
      },
      usage: {
        featureAdoption: [],
        userRetention: [],
        seasonality: {}
      }
    };
    
    try {
      // ÊôÇÈñìÂà•„Éà„É¨„É≥„ÉâÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      trends.traffic.hourly = Array.from({ length: 24 }, (_, i) => ({
        hour: i,
        requests: Math.floor(Math.random() * 100) + 20 + (i >= 8 && i <= 20 ? 50 : 0) // Êó•‰∏≠„ÅØÂ§ö„ÇÅ
      }));
      
      // Êó•Âà•„Éà„É¨„É≥„ÉâÔºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      trends.traffic.daily = Array.from({ length: 7 }, (_, i) => ({
        day: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][i],
        requests: Math.floor(Math.random() * 500) + 100 + (i < 5 ? 200 : 0) // Âπ≥Êó•„ÅØÂ§ö„ÇÅ
      }));
      
      // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂ±•Ê≠¥Ôºà„Ç∑„Éü„É•„É¨„Éº„Ç∑„Éß„É≥Ôºâ
      trends.performance.responseTimeHistory = Array.from({ length: 30 }, (_, i) => ({
        date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        avgResponseTime: Math.random() * 500 + 200 + Math.sin(i / 5) * 100
      }));
      
      // „Éà„É¨„É≥„ÉâÂà§ÂÆö
      const recentAvg = trends.performance.responseTimeHistory.slice(-7).reduce((a, b) => a + b.avgResponseTime, 0) / 7;
      const previousAvg = trends.performance.responseTimeHistory.slice(-14, -7).reduce((a, b) => a + b.avgResponseTime, 0) / 7;
      
      if (recentAvg > previousAvg * 1.1) {
        trends.performance.trend = 'degrading';
      } else if (recentAvg < previousAvg * 0.9) {
        trends.performance.trend = 'improving';
      } else {
        trends.performance.trend = 'stable';
      }
      
      return trends;
      
    } catch (error) {
      return { ...trends, error: error.message };
    }
  }

  /**
   * üîÆ ‰∫àÊ∏¨ÂàÜÊûê
   */
  async generatePredictiveAnalysis() {
    const predictions = {
      traffic: {
        nextHour: 0,
        nextDay: 0,
        nextWeek: 0,
        confidence: 0.8
      },
      resources: {
        predictedLoad: 0,
        scaleRecommendation: 'maintain',
        timeToScale: null
      },
      maintenance: {
        nextMaintenanceWindow: null,
        predictedIssues: [],
        preventiveMeasures: []
      }
    };
    
    try {
      // „Éà„É©„Éï„Ç£„ÉÉ„ÇØ‰∫àÊ∏¨Ôºà„Ç∑„É≥„Éó„É´„Å™Á∑öÂΩ¢‰∫àÊ∏¨Ôºâ
      const currentHour = new Date().getHours();
      const baseTraffic = 50;
      const hourlyMultiplier = currentHour >= 8 && currentHour <= 20 ? 2 : 1;
      
      predictions.traffic.nextHour = Math.floor(baseTraffic * hourlyMultiplier * (1 + Math.random() * 0.2));
      predictions.traffic.nextDay = Math.floor(predictions.traffic.nextHour * 24 * 0.8);
      predictions.traffic.nextWeek = Math.floor(predictions.traffic.nextDay * 7 * 0.9);
      
      // „É™„ÇΩ„Éº„Çπ‰∫àÊ∏¨
      if (predictions.traffic.nextWeek > 10000) {
        predictions.resources.scaleRecommendation = 'scale_up';
        predictions.resources.timeToScale = '3-5 days';
      } else if (predictions.traffic.nextWeek < 1000) {
        predictions.resources.scaleRecommendation = 'scale_down';
        predictions.resources.timeToScale = '1 week';
      }
      
      // ‰∫àÈò≤‰øùÂÆà
      predictions.maintenance.nextMaintenanceWindow = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString();
      predictions.maintenance.preventiveMeasures = [
        'Database optimization',
        'Cache cleanup',
        'Log rotation',
        'Security patches'
      ];
      
      return predictions;
      
    } catch (error) {
      return { ...predictions, error: error.message };
    }
  }

  /**
   * üí° „Ç§„É≥„Çµ„Ç§„ÉàÁîüÊàê
   */
  async generateInsights(sections) {
    const insights = [];
    
    try {
      // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Ç§„É≥„Çµ„Ç§„Éà
      if (sections.performance?.responseTime?.avg > 1000) {
        insights.push({
          type: 'performance',
          severity: 'warning',
          title: 'Response time degradation detected',
          description: `Average response time is ${sections.performance.responseTime.avg.toFixed(0)}ms, which is above the 1000ms threshold.`,
          recommendation: 'Consider database query optimization or adding caching.'
        });
      }
      
      // ‰ΩøÁî®Áä∂Ê≥Å„Ç§„É≥„Çµ„Ç§„Éà
      if (sections.usage?.scenarios?.todayGenerated > sections.usage?.scenarios?.total * 0.1) {
        insights.push({
          type: 'usage',
          severity: 'info',
          title: 'High scenario generation activity',
          description: `${sections.usage.scenarios.todayGenerated} scenarios generated today, representing ${((sections.usage.scenarios.todayGenerated / sections.usage.scenarios.total) * 100).toFixed(1)}% of total scenarios.`,
          recommendation: 'Consider promoting popular features or analyzing user behavior patterns.'
        });
      }
      
      // „Ç∑„Çπ„ÉÜ„É†„Ç§„É≥„Çµ„Ç§„Éà
      if (sections.system?.health?.status !== 'healthy') {
        insights.push({
          type: 'system',
          severity: 'critical',
          title: 'System health degraded',
          description: `System status is currently: ${sections.system.health.status}`,
          recommendation: 'Immediate investigation required for system stability.'
        });
      }
      
      // „Éà„É¨„É≥„Éâ„Ç§„É≥„Çµ„Ç§„Éà
      if (sections.trends?.performance?.trend === 'degrading') {
        insights.push({
          type: 'trend',
          severity: 'warning',
          title: 'Performance trend declining',
          description: 'Performance metrics show a declining trend over the past week.',
          recommendation: 'Analyze recent changes and consider performance optimization.'
        });
      }
      
      return insights;
      
    } catch (error) {
      return [{ type: 'error', severity: 'error', title: 'Insight generation failed', description: error.message }];
    }
  }

  /**
   * üìã Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
   */
  async generateRecommendations(sections) {
    const recommendations = [];
    
    try {
      // „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊé®Â•®‰∫ãÈ†Ö
      if (sections.performance?.bottlenecks?.length > 0) {
        recommendations.push({
          category: 'performance',
          priority: 'high',
          title: 'Address performance bottlenecks',
          actions: sections.performance.optimizations,
          impact: 'Improved user experience and system efficiency'
        });
      }
      
      // „Çπ„Ç±„Éº„É™„É≥„Ç∞Êé®Â•®‰∫ãÈ†Ö
      if (sections.predictions?.resources?.scaleRecommendation !== 'maintain') {
        recommendations.push({
          category: 'scaling',
          priority: 'medium',
          title: `Resource scaling recommended: ${sections.predictions.resources.scaleRecommendation}`,
          actions: [`Plan for scaling in ${sections.predictions.resources.timeToScale}`],
          impact: 'Optimal resource utilization and cost management'
        });
      }
      
      // „Çª„Ç≠„É•„É™„ÉÜ„Ç£Êé®Â•®‰∫ãÈ†Ö
      recommendations.push({
        category: 'security',
        priority: 'medium',
        title: 'Regular security maintenance',
        actions: ['Update dependencies', 'Review access logs', 'Rotate API keys'],
        impact: 'Enhanced security posture'
      });
      
      // „É¶„Éº„Ç∂„Éº„Ç®„ÇØ„Çπ„Éö„É™„Ç®„É≥„ÇπÊé®Â•®‰∫ãÈ†Ö
      if (sections.usage?.features?.mostUsed?.length > 0) {
        const topFeature = sections.usage.features.mostUsed[0];
        recommendations.push({
          category: 'user_experience',
          priority: 'low',
          title: 'Optimize popular features',
          actions: [`Focus development on ${topFeature.feature} improvements`],
          impact: 'Better user satisfaction and engagement'
        });
      }
      
      return recommendations;
      
    } catch (error) {
      return [{ category: 'error', priority: 'high', title: 'Recommendation generation failed', actions: [error.message] }];
    }
  }

  /**
   * üö® „Ç¢„É©„Éº„ÉàÁ¢∫Ë™ç
   */
  async checkAlerts(sections) {
    const alerts = [];
    
    try {
      // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Ç¢„É©„Éº„Éà
      if (sections.performance?.responseTime?.avg > 2000) {
        alerts.push({
          level: 'critical',
          type: 'performance',
          message: 'Critical: Average response time exceeds 2000ms',
          timestamp: new Date().toISOString(),
          actionRequired: true
        });
      }
      
      // „Ç∑„Çπ„ÉÜ„É†„Ç¢„É©„Éº„Éà
      if (sections.system?.health?.status === 'unhealthy') {
        alerts.push({
          level: 'critical',
          type: 'system',
          message: 'Critical: System health is unhealthy',
          timestamp: new Date().toISOString(),
          actionRequired: true
        });
      }
      
      // „É™„ÇΩ„Éº„Çπ„Ç¢„É©„Éº„Éà
      if (sections.performance?.resources?.memoryUsage > 90) {
        alerts.push({
          level: 'warning',
          type: 'resources',
          message: `Warning: High memory usage (${sections.performance.resources.memoryUsage.toFixed(1)}%)`,
          timestamp: new Date().toISOString(),
          actionRequired: false
        });
      }
      
      return alerts;
      
    } catch (error) {
      return [{
        level: 'error',
        type: 'system',
        message: `Alert check failed: ${error.message}`,
        timestamp: new Date().toISOString(),
        actionRequired: true
      }];
    }
  }

  // „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£„É°„ÇΩ„ÉÉ„Éâ
  async runPerformanceTests() {
    const tests = {
      responseTime: { avg: 0, p95: 0, p99: 0, min: 0, max: 0 },
      throughput: { requestsPerSecond: 0, peakRPS: 0, avgRPS: 0 }
    };
    
    const responseTimes = [];
    
    // Ë§áÊï∞Âõû„ÅÆ„ÉÜ„Çπ„ÉàÂÆüË°å
    for (let i = 0; i < 10; i++) {
      const start = performance.now();
      try {
        await this.supabase.from('scenarios').select('id').limit(1);
        responseTimes.push(performance.now() - start);
      } catch (error) {
        responseTimes.push(5000); // „Ç®„É©„ÉºÊôÇ„ÅØ5Áßí„Å®„Åô„Çã
      }
    }
    
    responseTimes.sort((a, b) => a - b);
    
    tests.responseTime.avg = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
    tests.responseTime.min = responseTimes[0];
    tests.responseTime.max = responseTimes[responseTimes.length - 1];
    tests.responseTime.p95 = responseTimes[Math.floor(responseTimes.length * 0.95)];
    tests.responseTime.p99 = responseTimes[Math.floor(responseTimes.length * 0.99)];
    
    tests.throughput.avgRPS = 1000 / tests.responseTime.avg;
    tests.throughput.peakRPS = 1000 / tests.responseTime.min;
    
    return tests;
  }

  async healthCheck() {
    try {
      await this.supabase.from('scenarios').select('id').limit(1);
      return true;
    } catch (error) {
      return false;
    }
  }

  getDeploymentTime() {
    // ÂÆüÈöõ„ÅÆ„Éá„Éó„É≠„Ç§ÊôÇÈñì„ÇíÂèñÂæóÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
    return new Date(Date.now() - process.uptime() * 1000).toISOString();
  }
}

// API „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
export default async function handler(req, res) {
  setSecurityHeaders(res);
  
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }

  const { action } = req.query;
  const dashboard = new RealtimeAnalyticsDashboard();

  try {
    switch (action) {
      case 'comprehensive':
        const comprehensiveDashboard = await dashboard.generateComprehensiveDashboard();
        return res.status(200).json({
          success: true,
          dashboard: comprehensiveDashboard
        });

      case 'realtime':
        const realtimeStats = await dashboard.generateRealtimeStats();
        return res.status(200).json({
          success: true,
          realtime: realtimeStats
        });

      case 'performance':
        const performanceAnalysis = await dashboard.generatePerformanceAnalysis();
        return res.status(200).json({
          success: true,
          performance: performanceAnalysis
        });

      case 'usage':
        const usageAnalysis = await dashboard.generateUsageAnalysis();
        return res.status(200).json({
          success: true,
          usage: usageAnalysis
        });

      case 'system':
        const systemStatus = await dashboard.generateSystemStatus();
        return res.status(200).json({
          success: true,
          system: systemStatus
        });

      case 'trends':
        const trendAnalysis = await dashboard.generateTrendAnalysis();
        return res.status(200).json({
          success: true,
          trends: trendAnalysis
        });

      default:
        return res.status(200).json({
          success: true,
          message: '„É™„Ç¢„É´„Çø„Ç§„É†ÂàÜÊûê„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâAPI',
          availableActions: [
            'comprehensive - ÂåÖÊã¨ÁöÑ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ',
            'realtime - „É™„Ç¢„É´„Çø„Ç§„É†Áµ±Ë®à',
            'performance - „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÂàÜÊûê',
            'usage - ‰ΩøÁî®Áä∂Ê≥ÅÂàÜÊûê',
            'system - „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã',
            'trends - „Éà„É¨„É≥„ÉâÂàÜÊûê'
          ]
        });
    }
  } catch (error) {
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
}