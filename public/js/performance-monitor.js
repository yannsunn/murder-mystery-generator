/**
 * üìä Real-time Performance Monitor - LEGACY (Áµ±ÂêàÁâà„Å´ÁßªË°åÊ∏à„Åø)
 * @deprecated Áµ±ÂêàÁõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É† (/api/core/monitoring.js) „Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ
 * 
 * „Åì„ÅÆ„Éï„Ç°„Ç§„É´„ÅØÂæåÊñπ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÊÆã„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
 * Êñ∞„Åó„ÅÑÁµ±ÂêàÁõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†„Çí‰ΩøÁî®„Åô„Çã„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ
 */

// Áµ±ÂêàÁõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†„ÅÆ„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÁâà„ÇíË™≠„ÅøËæº„Åø
// ÂÆüÈöõ„ÅÆÂÆüË£Ö„ÅØ /api/core/monitoring.js „Å´„ÅÇ„Çä„Åæ„Åô

class LegacyPerformanceMonitor {
  constructor() {
    this.metrics = {
      coreWebVitals: {},
      resourceTiming: [],
      userTiming: [],
      memoryUsage: [],
      networkTiming: [],
      errorLog: []
    };
    
    this.observers = [];
    this.isMonitoring = false;
    this.reportingInterval = null;
    this.thresholds = {
      LCP: 2500, // Largest Contentful Paint
      FID: 100,  // First Input Delay
      CLS: 0.1,  // Cumulative Layout Shift
      FCP: 1800, // First Contentful Paint
      TTFB: 800  // Time to First Byte
    };
    
    this.alerts = [];
    this.performanceScore = 100;
  }

  /**
   * Áõ£Ë¶ñÈñãÂßã
   */
  startMonitoring() {
    if (this.isMonitoring) {
      return;
    }

    logger.info('üìä Performance monitoring started');
    this.isMonitoring = true;

    // Core Web Vitals Áõ£Ë¶ñ
    this.initCoreWebVitals();
    
    // Resource timing Áõ£Ë¶ñ
    this.initResourceTimingObserver();
    
    // Memory usage Áõ£Ë¶ñ
    this.initMemoryMonitoring();
    
    // Navigation timing Áõ£Ë¶ñ
    this.initNavigationTiming();
    
    // Error tracking Áõ£Ë¶ñ
    this.initErrorTracking();
    
    // Long task Áõ£Ë¶ñ
    this.initLongTaskObserver();
    
    // Layout shift Áõ£Ë¶ñ
    this.initLayoutShiftObserver();

    // ÂÆöÊúü„É¨„Éù„Éº„ÉàÈñãÂßã
    this.startPeriodicReporting();
  }

  /**
   * Core Web Vitals ÂàùÊúüÂåñ
   */
  initCoreWebVitals() {
    // LCP (Largest Contentful Paint)
    if ('PerformanceObserver' in window) {
      try {
        const lcpObserver = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const lastEntry = entries[entries.length - 1];
          
          this.metrics.coreWebVitals.LCP = {
            value: lastEntry.startTime,
            rating: this.rateMetric('LCP', lastEntry.startTime),
            timestamp: Date.now()
          };
          
          this.checkThreshold('LCP', lastEntry.startTime);
        });
        
        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });
        this.observers.push(lcpObserver);
      } catch (e) {
        logger.warn('LCP observer not supported');
      }
    }

    // FCP (First Contentful Paint)
    try {
      const fcpObserver = new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        entries.forEach(entry => {
          if (entry.name === 'first-contentful-paint') {
            this.metrics.coreWebVitals.FCP = {
              value: entry.startTime,
              rating: this.rateMetric('FCP', entry.startTime),
              timestamp: Date.now()
            };
            
            this.checkThreshold('FCP', entry.startTime);
          }
        });
      });
      
      fcpObserver.observe({ entryTypes: ['paint'] });
      this.observers.push(fcpObserver);
    } catch (e) {
      logger.warn('FCP observer not supported');
    }

    // FID (First Input Delay) - event listener „Å®„Åó„Å¶ÂÆüË£Ö
    const firstInputHandler = (event) => {
      const now = performance.now();
      const fid = now - event.timeStamp;
      
      this.metrics.coreWebVitals.FID = {
        value: fid,
        rating: this.rateMetric('FID', fid),
        timestamp: Date.now()
      };
      
      this.checkThreshold('FID', fid);
      
      // ‰∏ÄÂ∫¶„Å†„ÅëÊ∏¨ÂÆö
      ['mousedown', 'keydown', 'touchstart', 'pointerdown'].forEach(type => {
        document.removeEventListener(type, firstInputHandler, true);
      });
    };

    ['mousedown', 'keydown', 'touchstart', 'pointerdown'].forEach(type => {
      document.addEventListener(type, firstInputHandler, true);
    });
  }

  /**
   * Layout Shift Áõ£Ë¶ñ
   */
  initLayoutShiftObserver() {
    if (!('PerformanceObserver' in window)) return;

    let clsValue = 0;
    let sessionValue = 0;
    let sessionEntries = [];

    try {
      const clsObserver = new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
          // „Çª„ÉÉ„Ç∑„Éß„É≥„Ç¶„Ç£„É≥„Éâ„Ç¶ÂÜÖ„Åß„ÅÆCLSË®àÁÆó
          if (!entry.hadRecentInput) {
            const firstSessionEntry = sessionEntries[0];
            const lastSessionEntry = sessionEntries[sessionEntries.length - 1];

            // Êñ∞„Åó„ÅÑ„Çª„ÉÉ„Ç∑„Éß„É≥„Åã„ÉÅ„Çß„ÉÉ„ÇØÔºà5Áßí‰ª•‰∏ä„ÅÆÈñìÈöîÔºâ
            if (sessionValue && 
                entry.startTime - lastSessionEntry.startTime > 5000) {
              clsValue = Math.max(clsValue, sessionValue);
              sessionValue = 0;
              sessionEntries = [];
            }

            sessionValue += entry.value;
            sessionEntries.push(entry);
          }
        }

        // ÁèæÂú®„ÅÆCLSÂÄ§„ÇíÊõ¥Êñ∞
        const currentCLS = Math.max(clsValue, sessionValue);
        
        this.metrics.coreWebVitals.CLS = {
          value: currentCLS,
          rating: this.rateMetric('CLS', currentCLS),
          timestamp: Date.now()
        };
        
        this.checkThreshold('CLS', currentCLS);
      });

      clsObserver.observe({ entryTypes: ['layout-shift'] });
      this.observers.push(clsObserver);
    } catch (e) {
      logger.warn('Layout Shift observer not supported');
    }
  }

  /**
   * Resource Timing Áõ£Ë¶ñ
   */
  initResourceTimingObserver() {
    if (!('PerformanceObserver' in window)) return;

    try {
      const resourceObserver = new PerformanceObserver((entryList) => {
        entryList.getEntries().forEach(entry => {
          const resourceData = {
            name: entry.name,
            type: this.getResourceType(entry.name),
            startTime: entry.startTime,
            duration: entry.duration,
            size: entry.transferSize || 0,
            cached: entry.transferSize === 0 && entry.decodedBodySize > 0,
            timestamp: Date.now()
          };
          
          this.metrics.resourceTiming.push(resourceData);
          
          // ÈÅÖ„ÅÑ„É™„ÇΩ„Éº„Çπ„ÅÆÊ§úÂá∫
          if (entry.duration > 3000) { // 3Áßí‰ª•‰∏ä
            this.addAlert('slow-resource', `Slow resource: ${entry.name} (${Math.round(entry.duration)}ms)`);
          }
          
          // „É™„Çπ„Éà„Çµ„Ç§„Ç∫Âà∂Èôê
          if (this.metrics.resourceTiming.length > 100) {
            this.metrics.resourceTiming.shift();
          }
        });
      });

      resourceObserver.observe({ entryTypes: ['resource'] });
      this.observers.push(resourceObserver);
    } catch (e) {
      logger.warn('Resource timing observer not supported');
    }
  }

  /**
   * Long Task Áõ£Ë¶ñ
   */
  initLongTaskObserver() {
    if (!('PerformanceObserver' in window)) return;

    try {
      const longTaskObserver = new PerformanceObserver((entryList) => {
        entryList.getEntries().forEach(entry => {
          const taskData = {
            name: entry.name,
            startTime: entry.startTime,
            duration: entry.duration,
            timestamp: Date.now()
          };
          
          this.metrics.userTiming.push(taskData);
          
          // Èï∑„ÅÑ„Çø„Çπ„ÇØ„Çí„Ç¢„É©„Éº„Éà„Å®„Åó„Å¶Ë®òÈå≤
          this.addAlert('long-task', `Long task detected: ${Math.round(entry.duration)}ms`);
          
          // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Çπ„Ç≥„Ç¢„ÇíÊ∏õÁÇπ
          this.performanceScore = Math.max(0, this.performanceScore - 5);
        });
      });

      longTaskObserver.observe({ entryTypes: ['longtask'] });
      this.observers.push(longTaskObserver);
    } catch (e) {
      logger.warn('Long task observer not supported');
    }
  }

  /**
   * Memory ‰ΩøÁî®ÈáèÁõ£Ë¶ñ
   */
  initMemoryMonitoring() {
    if (!('memory' in performance)) {
      logger.warn('Memory API not supported');
      return;
    }

    const checkMemory = () => {
      if (this.isMonitoring) {
        const memory = performance.memory;
        const memoryData = {
          used: memory.usedJSHeapSize,
          total: memory.totalJSHeapSize,
          limit: memory.jsHeapSizeLimit,
          timestamp: Date.now()
        };
        
        this.metrics.memoryUsage.push(memoryData);
        
        // „É°„É¢„É™‰ΩøÁî®Áéá„ÉÅ„Çß„ÉÉ„ÇØ
        const usage = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
        if (usage > 90) {
          this.addAlert('memory-high', `High memory usage: ${usage.toFixed(1)}%`);
        }
        
        // „É™„Çπ„Éà„Çµ„Ç§„Ç∫Âà∂Èôê
        if (this.metrics.memoryUsage.length > 50) {
          this.metrics.memoryUsage.shift();
        }
        
        setTimeout(checkMemory, 5000); // 5Áßí„Åî„Å®
      }
    };

    checkMemory();
  }

  /**
   * Navigation Timing Áõ£Ë¶ñ
   */
  initNavigationTiming() {
    if (!('PerformanceNavigationTiming' in window)) {
      logger.warn('Navigation Timing API not supported');
      return;
    }

    const navigation = performance.getEntriesByType('navigation')[0];
    if (navigation) {
      const ttfb = navigation.responseStart - navigation.requestStart;
      const domContentLoaded = navigation.domContentLoadedEventEnd - navigation.navigationStart;
      const loadComplete = navigation.loadEventEnd - navigation.navigationStart;
      
      this.metrics.networkTiming = {
        TTFB: ttfb,
        domContentLoaded,
        loadComplete,
        dnsLookup: navigation.domainLookupEnd - navigation.domainLookupStart,
        tcpConnect: navigation.connectEnd - navigation.connectStart,
        timestamp: Date.now()
      };
      
      this.checkThreshold('TTFB', ttfb);
    }
  }

  /**
   * Error tracking ÂàùÊúüÂåñ
   */
  initErrorTracking() {
    // JavaScript „Ç®„É©„Éº
    window.addEventListener('error', (event) => {
      this.addError('js-error', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });

    // Promise rejection
    window.addEventListener('unhandledrejection', (event) => {
      this.addError('promise-rejection', {
        reason: event.reason?.toString() || 'Unknown reason'
      });
    });

    // Resource load errors
    document.addEventListener('error', (event) => {
      if (event.target !== window) {
        this.addError('resource-error', {
          element: event.target.tagName,
          source: event.target.src || event.target.href,
          message: 'Failed to load resource'
        });
      }
    }, true);
  }

  /**
   * „Ç®„É©„ÉºËøΩÂä†
   */
  addError(type, details) {
    const error = {
      type,
      details,
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    this.metrics.errorLog.push(error);
    
    // „Ç®„É©„Éº„Ç¢„É©„Éº„Éà
    this.addAlert('error', `${type}: ${details.message || details.reason || 'Unknown error'}`);
    
    // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Çπ„Ç≥„Ç¢„ÇíÊ∏õÁÇπ
    this.performanceScore = Math.max(0, this.performanceScore - 10);
    
    // „É™„Çπ„Éà„Çµ„Ç§„Ç∫Âà∂Èôê
    if (this.metrics.errorLog.length > 50) {
      this.metrics.errorLog.shift();
    }
  }

  /**
   * „Ç¢„É©„Éº„ÉàËøΩÂä†
   */
  addAlert(type, message) {
    const alert = {
      type,
      message,
      timestamp: Date.now(),
      severity: this.getAlertSeverity(type)
    };
    
    this.alerts.push(alert);
    
    // ÈáçË¶ÅÂ∫¶„Å´Âøú„Åò„Å¶„É≠„Ç∞Âá∫Âäõ
    if (alert.severity === 'high') {
      logger.error(`üö® Performance Alert: ${message}`);
    } else if (alert.severity === 'medium') {
      logger.warn(`‚ö†Ô∏è Performance Warning: ${message}`);
    } else {
      logger.debug(`‚ÑπÔ∏è Performance Info: ${message}`);
    }
    
    // „Ç¢„É©„Éº„ÉàÊï∞Âà∂Èôê
    if (this.alerts.length > 100) {
      this.alerts.shift();
    }
  }

  /**
   * „Åó„Åç„ÅÑÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
   */
  checkThreshold(metric, value) {
    const threshold = this.thresholds[metric];
    if (!threshold) return;

    const rating = this.rateMetric(metric, value);
    
    if (rating === 'poor') {
      this.addAlert('threshold-exceeded', 
        `${metric} exceeded threshold: ${value} > ${threshold}`);
      this.performanceScore = Math.max(0, this.performanceScore - 15);
    } else if (rating === 'needs-improvement') {
      this.performanceScore = Math.max(0, this.performanceScore - 5);
    }
  }

  /**
   * „É°„Éà„É™„ÇØ„ÇπË©ï‰æ°
   */
  rateMetric(metric, value) {
    const thresholds = {
      LCP: [2500, 4000],
      FID: [100, 300],
      CLS: [0.1, 0.25],
      FCP: [1800, 3000],
      TTFB: [800, 1800]
    };

    const [good, poor] = thresholds[metric] || [0, Infinity];
    
    if (value <= good) return 'good';
    if (value <= poor) return 'needs-improvement';
    return 'poor';
  }

  /**
   * „Ç¢„É©„Éº„ÉàÈáçË¶ÅÂ∫¶ÂèñÂæó
   */
  getAlertSeverity(type) {
    const severityMap = {
      'error': 'high',
      'threshold-exceeded': 'high',
      'memory-high': 'medium',
      'long-task': 'medium',
      'slow-resource': 'low'
    };
    
    return severityMap[type] || 'low';
  }

  /**
   * „É™„ÇΩ„Éº„Çπ„Çø„Ç§„ÉóÂà§ÂÆö
   */
  getResourceType(url) {
    if (url.includes('.css')) return 'stylesheet';
    if (url.includes('.js')) return 'script';
    if (url.match(/\.(jpg|jpeg|png|gif|webp|svg)$/i)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|eot)$/i)) return 'font';
    if (url.includes('/api/')) return 'api';
    return 'other';
  }

  /**
   * ÂÆöÊúü„É¨„Éù„Éº„ÉàÈñãÂßã
   */
  startPeriodicReporting() {
    this.reportingInterval = setInterval(() => {
      this.generatePerformanceReport();
    }, 30000); // 30Áßí„Åî„Å®
  }

  /**
   * „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„É¨„Éù„Éº„ÉàÁîüÊàê
   */
  generatePerformanceReport() {
    const report = {
      timestamp: Date.now(),
      score: this.calculatePerformanceScore(),
      coreWebVitals: this.metrics.coreWebVitals,
      summary: {
        totalResources: this.metrics.resourceTiming.length,
        totalErrors: this.metrics.errorLog.length,
        activeAlerts: this.alerts.filter(a => 
          Date.now() - a.timestamp < 300000 // 5ÂàÜ‰ª•ÂÜÖ
        ).length
      },
      recommendations: this.generateRecommendations()
    };

    // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
    this.updatePerformanceDashboard(report);
    
    return report;
  }

  /**
   * „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„Çπ„Ç≥„Ç¢Ë®àÁÆó
   */
  calculatePerformanceScore() {
    let score = 100;
    
    // Core Web Vitals „Å´„Çà„Çã„Çπ„Ç≥„Ç¢Ë™øÊï¥
    Object.entries(this.metrics.coreWebVitals).forEach(([metric, data]) => {
      if (data.rating === 'poor') {
        score -= 20;
      } else if (data.rating === 'needs-improvement') {
        score -= 10;
      }
    });
    
    // „Ç®„É©„Éº„Å´„Çà„Çã„Çπ„Ç≥„Ç¢Ë™øÊï¥
    const recentErrors = this.metrics.errorLog.filter(
      error => Date.now() - error.timestamp < 300000 // 5ÂàÜ‰ª•ÂÜÖ
    );
    score -= recentErrors.length * 5;
    
    // ÈÅÖ„ÅÑ„É™„ÇΩ„Éº„Çπ„Å´„Çà„Çã„Çπ„Ç≥„Ç¢Ë™øÊï¥
    const slowResources = this.metrics.resourceTiming.filter(
      resource => resource.duration > 3000
    );
    score -= slowResources.length * 3;
    
    return Math.max(0, Math.min(100, score));
  }

  /**
   * Êé®Â•®‰∫ãÈ†ÖÁîüÊàê
   */
  generateRecommendations() {
    const recommendations = [];
    
    // Core Web Vitals „ÅÆÊîπÂñÑÊèêÊ°à
    Object.entries(this.metrics.coreWebVitals).forEach(([metric, data]) => {
      if (data.rating === 'poor') {
        recommendations.push({
          type: 'critical',
          metric,
          message: this.getImprovementSuggestion(metric),
          priority: 'high'
        });
      }
    });
    
    // „É™„ÇΩ„Éº„ÇπÊúÄÈÅ©ÂåñÊèêÊ°à
    const largeResources = this.metrics.resourceTiming.filter(
      resource => resource.size > 1000000 // 1MB‰ª•‰∏ä
    );
    
    if (largeResources.length > 0) {
      recommendations.push({
        type: 'optimization',
        message: `${largeResources.length}ÂÄã„ÅÆÂ§ß„Åç„Å™„É™„ÇΩ„Éº„Çπ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÂúßÁ∏Æ„Åæ„Åü„ÅØÂàÜÂâ≤„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
        priority: 'medium'
      });
    }
    
    return recommendations;
  }

  /**
   * ÊîπÂñÑÊèêÊ°àÂèñÂæó
   */
  getImprovementSuggestion(metric) {
    const suggestions = {
      LCP: '„Çµ„Éº„Éê„ÉºÂøúÁ≠îÊôÇÈñì„ÅÆÊúÄÈÅ©Âåñ„ÄÅÁîªÂÉè„ÅÆÊúÄÈÅ©Âåñ„ÄÅ‰∏çË¶Å„Å™JavaScript„ÅÆÂâäÈô§„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      FID: 'JavaScript„ÅÆÂÆüË°åÊôÇÈñì„ÇíÁü≠Á∏Æ„ÄÅ„Ç≥„Éº„ÉâÂàÜÂâ≤„ÅÆÂÆüË£Ö„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      CLS: '„Çµ„Ç§„Ç∫„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÁîªÂÉè„ÇÑÂãïÁöÑ„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆ‰øÆÊ≠£„ÇíË°å„Å£„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      FCP: 'Critical CSS„ÅÆ„Ç§„É≥„É©„Ç§„É≥Âåñ„ÄÅ„Éï„Ç©„É≥„Éà„ÅÆÊúÄÈÅ©Âåñ„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
      TTFB: '„Çµ„Éº„Éê„ÉºÂá¶ÁêÜÊôÇÈñì„ÅÆÊúÄÈÅ©Âåñ„ÄÅCDN„ÅÆÂà©Áî®„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
    };
    
    return suggestions[metric] || '„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÅÆÊúÄÈÅ©Âåñ„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
  }

  /**
   * „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
   */
  updatePerformanceDashboard(report) {
    // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâË¶ÅÁ¥†„ÅÆ‰ΩúÊàê„ÉªÊõ¥Êñ∞
    let dashboard = document.getElementById('performance-dashboard');
    
    if (!dashboard) {
      dashboard = document.createElement('div');
      dashboard.id = 'performance-dashboard';
      dashboard.className = 'performance-dashboard';
      dashboard.innerHTML = `
        <div class="performance-header">
          <h3>üìä Performance Monitor</h3>
          <span class="performance-score" id="perf-score">100</span>
        </div>
        <div class="performance-metrics" id="perf-metrics"></div>
        <div class="performance-alerts" id="perf-alerts"></div>
      `;
      
      // Âè≥‰∏ã„Å´Âõ∫ÂÆöË°®Á§∫
      dashboard.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 320px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 15px;
        border-radius: 10px;
        font-size: 12px;
        z-index: 1000;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        max-height: 400px;
        overflow-y: auto;
      `;
      
      document.body.appendChild(dashboard);
    }
    
    // „Çπ„Ç≥„Ç¢Êõ¥Êñ∞
    const scoreElement = document.getElementById('perf-score');
    if (scoreElement) {
      const score = report.score;
      scoreElement.textContent = Math.round(score);
      scoreElement.style.color = score >= 80 ? '#4ade80' : score >= 60 ? '#fbbf24' : '#f87171';
    }
    
    // „É°„Éà„É™„ÇØ„ÇπÊõ¥Êñ∞
    const metricsElement = document.getElementById('perf-metrics');
    if (metricsElement) {
      metricsElement.innerHTML = Object.entries(report.coreWebVitals)
        .map(([metric, data]) => `
          <div class="metric">
            <span>${metric}:</span>
            <span class="metric-value metric-${data.rating}">
              ${Math.round(data.value)}${metric === 'CLS' ? '' : 'ms'}
            </span>
          </div>
        `).join('');
    }
    
    // „Ç¢„É©„Éº„ÉàÊõ¥Êñ∞
    const alertsElement = document.getElementById('perf-alerts');
    if (alertsElement) {
      const recentAlerts = this.alerts
        .filter(a => Date.now() - a.timestamp < 60000) // 1ÂàÜ‰ª•ÂÜÖ
        .slice(-3);
        
      alertsElement.innerHTML = recentAlerts
        .map(alert => `
          <div class="alert alert-${alert.severity}">
            ${alert.message}
          </div>
        `).join('');
    }
  }

  /**
   * Áõ£Ë¶ñÂÅúÊ≠¢
   */
  stopMonitoring() {
    this.isMonitoring = false;
    
    // Observer „ÅÆÂÅúÊ≠¢
    this.observers.forEach(observer => {
      try {
        observer.disconnect();
      } catch (e) {
        // ignore
      }
    });
    this.observers = [];
    
    // „É¨„Éù„Éº„ÉÜ„Ç£„É≥„Ç∞ÂÅúÊ≠¢
    if (this.reportingInterval) {
      clearInterval(this.reportingInterval);
      this.reportingInterval = null;
    }
    
    logger.info('üìä Performance monitoring stopped');
  }

  /**
   * „É°„Éà„É™„ÇØ„ÇπÂèñÂæó
   */
  getMetrics() {
    return {
      ...this.metrics,
      score: this.calculatePerformanceScore(),
      alerts: this.alerts
    };
  }

  /**
   * „É™„Çª„ÉÉ„Éà
   */
  reset() {
    this.metrics = {
      coreWebVitals: {},
      resourceTiming: [],
      userTiming: [],
      memoryUsage: [],
      networkTiming: [],
      errorLog: []
    };
    
    this.alerts = [];
    this.performanceScore = 100;
  }
}

// „Ç∞„É≠„Éº„Éê„É´„Ç§„É≥„Çπ„Çø„É≥„Çπ
window.performanceMonitor = new PerformanceMonitor();

// Ëá™ÂãïÈñãÂßã
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    window.performanceMonitor.startMonitoring();
  });
} else {
  window.performanceMonitor.startMonitoring();
}

// „Ç®„ÇØ„Çπ„Éù„Éº„Éà
export { PerformanceMonitor };