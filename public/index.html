<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Murder Mystery Generator - Professional Edition</title>
  <meta name="description" content="世界最速のマーダーミステリー生成システム - AI駆動・タイムアウトフリー">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="simple-modern-style.css">
  <link rel="stylesheet" href="ultra-enhanced-animations.css">
  <link rel="stylesheet" href="ultra-smooth-navigation.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='45' fill='%236d28d9'/><text y='65' x='50' text-anchor='middle' font-size='60' fill='white'>M</text></svg>">
</head>
<body>
  <header>
    <h1>Murder Mystery Generator</h1>
    <p>AI駆動マーダーミステリー生成システム</p>
  </header>

  <!-- 🎨 メインコンテンツ -->
  <main class="main-container">
    <!-- 🎯 メインカード -->
    <div class="card" id="main-card">
      <div class="card-header">
        <h2>シナリオ生成システム</h2>
        <p>プロフェッショナル品質のマーダーミステリーシナリオを効率的に生成</p>
      </div>
      
      <!-- 🎪 革命的ステップインジケーター -->
      <div class="step-indicator" id="step-indicator">
        <div class="step-indicator-item active" data-step="1" data-title="基本設定">
          <span>1</span>
          <div class="step-title">基本設定</div>
        </div>
        <div class="step-line"></div>
        <div class="step-indicator-item" data-step="2" data-title="世界観">
          <span>2</span>
          <div class="step-title">世界観</div>
        </div>
        <div class="step-line"></div>
        <div class="step-indicator-item" data-step="3" data-title="事件設定">
          <span>3</span>
          <div class="step-title">事件設定</div>
        </div>
        <div class="step-line"></div>
        <div class="step-indicator-item" data-step="4" data-title="詳細オプション">
          <span>4</span>
          <div class="step-title">詳細</div>
        </div>
        <div class="step-line"></div>
        <div class="step-indicator-item" data-step="5" data-title="確認・生成">
          <span>5</span>
          <div class="step-title">生成</div>
        </div>
      </div>
      
      <!-- 🔥 フォームコンテナ -->
      <form id="scenario-form" class="form-container">
        <div id="step-container">
          
          <!-- ステップ1: 基本設定 -->
          <div id="step-1" class="step active">
            <div class="step-header">
              <h3 class="text-gradient">🎮 基本設定</h3>
              <p>マーダーミステリーの基本パラメータを設定します</p>
            </div>
            
            <div class="form-grid">
              <div class="form-group">
                <label for="participants" class="form-label">👥 参加人数</label>
                <select id="participants" name="participants" class="form-select">
                  <option value="4">4人 (コンパクト)</option>
                  <option value="5" selected>5人 (推奨)</option>
                  <option value="6">6人 (標準)</option>
                  <option value="7">7人 (大規模)</option>
                  <option value="8">8人 (エピック)</option>
                </select>
                <div class="form-hint">推奨は5-6人です</div>
              </div>
              
              <div class="form-group">
                <label for="era" class="form-label">⏰ 時代背景</label>
                <select id="era" name="era" class="form-select">
                  <option value="modern" selected>🏙️ 現代 (2020年代)</option>
                  <option value="showa">🏮 昭和 (1926-1989)</option>
                  <option value="near-future">🚀 近未来 (2030年代)</option>
                  <option value="fantasy">🏰 ファンタジー</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="setting" class="form-label">🏢 舞台設定</label>
                <select id="setting" name="setting" class="form-select">
                  <option value="closed-space" selected>🏠 閉鎖空間 (密室)</option>
                  <option value="mountain-villa">🏔️ 山荘 (隔離)</option>
                  <option value="military-facility">⚔️ 軍事施設</option>
                  <option value="underwater-facility">🌊 海中施設</option>
                  <option value="city">🌆 都市部</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- ステップ2: 世界観 -->
          <div id="step-2" class="step next">
            <div class="step-header">
              <h3 class="text-gradient">🌟 世界観とトーン</h3>
              <p>シナリオの雰囲気と世界観を決定します</p>
            </div>
            
            <div class="form-grid">
              <div class="form-group">
                <label for="worldview" class="form-label">🌍 世界観</label>
                <select id="worldview" name="worldview" class="form-select">
                  <option value="realistic" selected>📱 リアル志向 (現実的)</option>
                  <option value="occult">👻 オカルト要素あり</option>
                  <option value="sci-fi">🛸 SF要素あり</option>
                  <option value="mystery">🔍 純粋ミステリー</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="tone" class="form-label">🎭 トーン・雰囲気</label>
                <select id="tone" name="tone" class="form-select">
                  <option value="serious" selected>😐 シリアス (重厚)</option>
                  <option value="comedy">😄 コメディ (軽快)</option>
                  <option value="horror">😱 ホラー (恐怖)</option>
                  <option value="adventure">🗺️ 冒険活劇</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- ステップ3: 事件設定 -->
          <div id="step-3" class="step next">
            <div class="step-header">
              <h3 class="text-gradient">🔍 事件設定</h3>
              <p>発生する事件の種類と詳細を設定します</p>
            </div>
            
            <div class="form-grid">
              <div class="form-group">
                <label for="incident_type" class="form-label">⚡ 事件の種類</label>
                <select id="incident_type" name="incident_type" class="form-select">
                  <option value="murder" selected>💀 殺人事件</option>
                  <option value="disappearance">👤 失踪事件</option>
                  <option value="theft">💎 盗難事件</option>
                  <option value="blackmail">📧 恐喝事件</option>
                  <option value="fraud">💰 詐欺事件</option>
                </select>
              </div>
            </div>
          </div>
          
          <!-- ステップ4: 詳細オプション -->
          <div id="step-4" class="step next">
            <div class="step-header">
              <h3 class="text-gradient">⚙️ 詳細オプション</h3>
              <p>シナリオの複雑さと特殊要素を調整します</p>
            </div>
            
            <div class="form-grid">
              <div class="form-group">
                <label for="complexity" class="form-label">🧩 複雑さレベル</label>
                <select id="complexity" name="complexity" class="form-select">
                  <option value="simple">🟢 シンプル (初心者向け)</option>
                  <option value="standard" selected>🟡 標準 (推奨)</option>
                  <option value="complex">🔴 複雑 (上級者向け)</option>
                </select>
              </div>
              
              <div class="checkbox-group">
                <label class="checkbox-label">
                  <input type="checkbox" id="red_herring" name="red_herring" class="checkbox-input">
                  <span class="checkbox-custom"></span>
                  <span class="checkbox-text">🎯 レッドヘリング (偽の手がかり)</span>
                </label>
                
                <label class="checkbox-label">
                  <input type="checkbox" id="twist_ending" name="twist_ending" class="checkbox-input">
                  <span class="checkbox-custom"></span>
                  <span class="checkbox-text">🌪️ どんでん返し</span>
                </label>
                
                <label class="checkbox-label">
                  <input type="checkbox" id="secret_roles" name="secret_roles" class="checkbox-input">
                  <span class="checkbox-custom"></span>
                  <span class="checkbox-text">🎭 秘密の役割</span>
                </label>
              </div>
            </div>
          </div>
          
          <!-- ステップ5: 確認・生成 -->
          <div id="step-5" class="step next">
            <div class="step-header">
              <h3 class="text-gradient">🚀 最終確認</h3>
              <p>設定を確認して、超高速生成を開始します</p>
            </div>
            
            <div id="summary-container" class="summary-container">
              <div class="summary-card">
                <h4>📋 設定サマリー</h4>
                <div id="settings-summary" class="settings-summary">
                  <!-- 動的に生成される設定サマリー -->
                </div>
              </div>
              
              <div class="generation-info">
                <div class="info-item">
                  <span class="info-icon">⚡</span>
                  <span class="info-text">予想生成時間: <strong>45秒以内</strong></span>
                </div>
                <div class="info-item">
                  <span class="info-icon">🛡️</span>
                  <span class="info-text">フェイルセーフ: <strong>Groq → OpenAI</strong></span>
                </div>
                <div class="info-item">
                  <span class="info-icon">🎯</span>
                  <span class="info-text">成功率: <strong>99.9%保証</strong></span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- ナビゲーションボタン - 完全固定位置 -->
        <div class="button-container">
          <button type="button" id="prev-btn" class="btn btn-secondary" disabled>
            <span>←</span> 前へ
          </button>
          <div class="btn-spacer"></div>
          <button type="button" id="next-btn" class="btn btn-primary">
            次へ <span>→</span>
          </button>
          <button type="button" id="stepwise-generation-btn" class="btn btn-success" style="display: none;">
            <span>🚀</span> 生成開始
          </button>
        </div>
      </form>
    </div>
    
    <!-- ローディング表示 -->
    <div id="loading-indicator" class="card hidden">
      <div class="loading-container">
        <div class="loading-header">
          <h3>🚀 AIシナリオ生成中...</h3>
          <div class="progress-percentage" id="progress-percentage">0%</div>
        </div>
        
        <div class="progress-bar-container">
          <div class="progress-bar">
            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            <div class="progress-text" id="progress-text">準備中...</div>
          </div>
        </div>
        
        <div class="phase-info">
          <div class="current-phase" id="current-phase">🚀 システム初期化中...</div>
          <div class="phase-details" id="phase-details">AI エンジン起動中...</div>
        </div>
        
        <div class="loading-stats">
          <div class="stat-item">
            <span class="stat-label">処理フェーズ</span>
            <span class="stat-value" id="current-phase-number">1/8</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">推定残り時間</span>
            <span class="stat-value" id="estimated-time">計算中...</span>
          </div>
          <div class="stat-item">
            <span class="stat-label">生成方式</span>
            <span class="stat-value" id="generation-method">AI並列処理</span>
          </div>
        </div>
        
        <!-- ARIA Live Region for Progress Updates -->
        <div id="progress-announcements" aria-live="polite" aria-atomic="true" class="sr-only">
          進行状況の更新がここに表示されます
        </div>
        
        <div class="loading-spinner"></div>
      </div>
    </div>
    
    <!-- 結果表示 -->
    <div id="result-container" class="card hidden">
      <div class="result-header">
        <h2>🎉 生成完了</h2>
        <p>マーダーミステリーシナリオが完成しました</p>
      </div>
      
      <div class="result-content">
        <div class="scenario-content" id="scenario-content">
          <!-- 生成されたシナリオがここに表示される -->
        </div>
        
        <!-- 追加コンテンツ表示エリア -->
        <div id="additional-content" class="additional-content hidden">
          <!-- 追加コンテンツがここに動的に表示される -->
        </div>
        
        <!-- ハンドアウト表示エリア -->
        <div id="handouts-container" class="handouts-container" style="display: none;">
          <h3>📄 キャラクターハンドアウト</h3>
          <div id="handouts-list" class="handouts-list">
            <!-- ハンドアウトがここに表示されます -->
          </div>
        </div>
      </div>
      
      <!-- 動的アクションボタンはJavaScriptで生成されます -->
      <div id="dynamic-actions" class="result-actions">
        <!-- アクションボタンはMurderMysteryApp.jsのaddActionButtons()で動的に生成 -->
      </div>
    </div>
    
    <!-- 🚨 エラー表示 -->
    <div id="error-container" class="error-container hidden">
      <div class="error-message" id="error-message">
        <!-- エラーメッセージがここに表示される -->
      </div>
      <button id="retry-btn" class="btn btn-primary" style="margin-top: 1rem;">
        <span>🔄</span> 再試行
      </button>
    </div>
  </main>

  <footer style="text-align: center; padding: 2rem; color: #64748b; font-size: 0.9rem; background: var(--bg-secondary); border-top: 1px solid var(--accent-soft);">
    <p>Murder Mystery Generator | Professional AI-Powered System</p>
  </footer>

  <!-- 🚀 ULTRA-SYNCHRONIZED SYSTEM V3.0 - BEYOND LIMITS -->
  <script type="module">
    // ULTRA INITIALIZATION - BREAKTHROUGH PERFORMANCE
    const timestamp = Date.now();
    const version = '3.0.0-ULTRA';
    console.log(`🚀 Murder Mystery Generator ${version} [${timestamp}] - Ultra Sync Init`);
    
    // QUANTUM LOADER OVERLAY
    const overlay = document.createElement('div');
    overlay.id = 'ultra-init-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: linear-gradient(135deg, #0f1419, #1a202c, #2d3748); 
      display: flex; justify-content: center; align-items: center; 
      z-index: 20000; color: white; font-family: 'Inter', sans-serif;
    `;
    overlay.innerHTML = `
      <div style="text-align: center; max-width: 500px;">
        <div style="font-size: 5rem; margin-bottom: 1rem; animation: pulse 2s infinite;">🕵️</div>
        <h2 style="margin-bottom: 0.5rem; font-size: 2rem; font-weight: 800; background: linear-gradient(45deg, #667eea, #764ba2, #f093fb); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Murder Mystery Generator</h2>
        <p style="margin-bottom: 0.5rem; font-size: 1.2rem; color: #a0aec0;">ULTRA EDITION ${version}</p>
        <p style="margin-bottom: 2rem; font-size: 0.9rem; color: #718096;">量子加速モジュラーシステム初期化中...</p>
        
        <div style="width: 400px; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden; margin: 0 auto;">
          <div id="ultra-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #667eea, #764ba2, #f093fb); border-radius: 3px; transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);"></div>
        </div>
        
        <div id="ultra-status" style="margin-top: 1.5rem; font-size: 1rem; opacity: 0.9; min-height: 1.5rem;">量子コア起動中...</div>
        <div id="ultra-substatus" style="margin-top: 0.5rem; font-size: 0.8rem; opacity: 0.6; color: #a0aec0;">システム最適化実行中...</div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    function updateUltraProgress(percent, message, submessage = '') {
      const progress = document.getElementById('ultra-progress');
      const status = document.getElementById('ultra-status');
      const substatus = document.getElementById('ultra-substatus');
      if (progress) {
        progress.style.width = percent + '%';
        progress.style.filter = `brightness(${1 + percent/100})`;
      }
      if (status) status.textContent = message;
      if (substatus) substatus.textContent = submessage;
    }
    
    try {
      updateUltraProgress(10, '🔥 量子コアモジュール読み込み中...', 'EventEmitter + ApiClient 同期ロード');
      
      // ULTRA PARALLEL MODULE LOADING
      const modules = {};
      const loadPromises = [];
      
      // PARALLEL IMPORT WITH CACHE BUSTING
      loadPromises.push(
        import('./js/core/EventEmitter.js?v=' + timestamp)
          .then(module => { modules.EventEmitter = module.default; })
      );
      
      loadPromises.push(
        import('./js/core/ApiClient.js?v=' + timestamp)
          .then(module => { modules.ApiClient = module.default; })
      );
      
      await Promise.all(loadPromises);
      updateUltraProgress(30, '⚡ APIクライアント量子初期化中...', 'ヘルスチェック & レート制限システム');
      
      // ULTRA API CLIENT WITH QUANTUM HEALTH CHECKS
      const apiClient = new modules.ApiClient({ 
        baseURL: '/api',
        timeout: 45000,
        maxRetries: 5,
        rateLimitDelay: 50 // Ultra-fast rate limiting
      });
      
      updateUltraProgress(50, '🚀 UIコントローラー超高速設定中...', 'イベントシステム + レスポンシブ制御');
      
      // ULTRA-RESPONSIVE UI CONTROLLER
      class UltraUIController extends modules.EventEmitter {
        constructor() {
          super();
          this.currentStep = 1;
          this.lastStep = null;
          this.totalSteps = 5;
          this.isGenerating = false;
          this.stepCache = new Map();
          this.debounceMap = new Map();
          this.setupUltraEventListeners();
          this.setupStepIndicators();
          this.setupFormValidation();
        }
        
        setupUltraEventListeners() {
          // ULTRA RESPONSIVE BUTTON HANDLING
          const prevBtn = document.getElementById('prev-btn');
          const nextBtn = document.getElementById('next-btn');
          const generateBtn = document.getElementById('stepwise-generation-btn');
          const retryBtn = document.getElementById('retry-btn');
          const generateNewBtn = document.getElementById('generate-new-btn');
          
          if (prevBtn) {
            prevBtn.addEventListener('click', (e) => {
              e.preventDefault();
              this.goToPreviousStep();
            });
          }
          
          if (nextBtn) {
            nextBtn.addEventListener('click', (e) => {
              e.preventDefault();
              this.goToNextStep();
            });
          }
          
          if (generateBtn) {
            generateBtn.addEventListener('click', (e) => {
              e.preventDefault();
              this.startUltraGeneration();
            });
          }
          
          if (retryBtn) {
            retryBtn.addEventListener('click', (e) => {
              e.preventDefault();
              this.hideError();
              this.startUltraGeneration();
            });
          }
          
          if (generateNewBtn) {
            generateNewBtn.addEventListener('click', (e) => {
              e.preventDefault();
              this.resetToStart();
            });
          }
          
          // アクションボタンは MurderMysteryApp.js で処理されます
          
          // FORM CHANGE DETECTION
          const form = document.getElementById('scenario-form');
          if (form) {
            form.addEventListener('change', (e) => {
              this.handleFormChange(e);
            });
          }
          
          // KEYBOARD SHORTCUTS
          document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
              switch(e.key) {
                case 'ArrowLeft':
                  e.preventDefault();
                  this.goToPreviousStep();
                  break;
                case 'ArrowRight':
                  e.preventDefault();
                  this.goToNextStep();
                  break;
                case 'Enter':
                  if (this.currentStep === this.totalSteps) {
                    e.preventDefault();
                    this.startUltraGeneration();
                  }
                  break;
              }
            }
          });
        }
        
        setupStepIndicators() {
          const indicators = document.querySelectorAll('.step-indicator-item');
          indicators.forEach((indicator, index) => {
            indicator.addEventListener('click', () => {
              if (index + 1 <= this.currentStep) {
                this.navigateToStep(index + 1);
              }
            });
          });
        }
        
        setupFormValidation() {
          // Real-time validation
          const requiredFields = ['participants', 'era', 'setting', 'worldview', 'tone', 'incident_type', 'complexity'];
          requiredFields.forEach(fieldName => {
            const field = document.getElementById(fieldName);
            if (field) {
              field.addEventListener('change', () => {
                this.validateField(fieldName, field.value);
              });
            }
          });
        }
        
        handleFormChange(event) {
          const { name, value, type, checked } = event.target;
          const fieldValue = type === 'checkbox' ? checked : value;
          
          // Debounced auto-save
          this.debounce(`save-${name}`, () => {
            this.saveFormData(name, fieldValue);
          }, 1000);
          
          // Real-time summary update
          if (this.currentStep === this.totalSteps) {
            this.updateSummary();
          }
          
          this.emit('form:change', { name, value: fieldValue });
        }
        
        validateField(name, value) {
          const isValid = value && value.trim() !== '';
          const field = document.getElementById(name);
          
          if (field) {
            field.classList.toggle('invalid', !isValid);
            field.classList.toggle('valid', isValid);
          }
          
          return isValid;
        }
        
        goToNextStep() {
          if (this.currentStep < this.totalSteps) {
            // Validate current step
            if (this.validateCurrentStep()) {
              this.currentStep++;
              this.updateStepDisplay();
              this.emit('step:next', { to: this.currentStep, from: this.currentStep - 1 });
            }
          }
        }
        
        goToPreviousStep() {
          if (this.currentStep > 1) {
            this.currentStep--;
            this.updateStepDisplay();
            this.emit('step:previous', { to: this.currentStep, from: this.currentStep + 1 });
          }
        }
        
        navigateToStep(targetStep) {
          if (targetStep >= 1 && targetStep <= this.totalSteps && targetStep <= this.currentStep) {
            const previousStep = this.currentStep;
            this.currentStep = targetStep;
            this.updateStepDisplay();
            this.emit('step:navigate', { to: targetStep, from: previousStep });
          }
        }
        
        validateCurrentStep() {
          // Step-specific validation logic
          switch (this.currentStep) {
            case 1:
              return this.validateField('participants', document.getElementById('participants')?.value) &&
                     this.validateField('era', document.getElementById('era')?.value) &&
                     this.validateField('setting', document.getElementById('setting')?.value);
            case 2:
              return this.validateField('worldview', document.getElementById('worldview')?.value) &&
                     this.validateField('tone', document.getElementById('tone')?.value);
            case 3:
              return this.validateField('incident_type', document.getElementById('incident_type')?.value);
            case 4:
              return this.validateField('complexity', document.getElementById('complexity')?.value);
            default:
              return true;
          }
        }
        
        updateStepDisplay() {
          // ULTRA SMOOTH STEP TRANSITION - NO VERTICAL MOVEMENT
          for (let i = 1; i <= this.totalSteps; i++) {
            const stepEl = document.getElementById('step-' + i);
            if (stepEl) {
              stepEl.classList.remove('active', 'previous', 'next', 'entering-from-right', 'entering-from-left');
              
              if (i < this.currentStep) {
                stepEl.classList.add('previous');
              } else if (i > this.currentStep) {
                stepEl.classList.add('next');
              }
            }
          }
          
          // 現在のステップをアクティブに
          const currentStepEl = document.getElementById('step-' + this.currentStep);
          if (currentStepEl) {
            currentStepEl.classList.add('active');
            
            // 進行方向に応じたアニメーション
            if (this.lastStep && this.currentStep > this.lastStep) {
              currentStepEl.classList.add('entering-from-right');
            } else if (this.lastStep && this.currentStep < this.lastStep) {
              currentStepEl.classList.add('entering-from-left');
            }
          }
          
          this.lastStep = this.currentStep;
          
          // Update step indicators
          this.updateStepIndicators();
          
          // Update button states
          this.updateButtonStates();
          
          // Update summary if on final step
          if (this.currentStep === this.totalSteps) {
            this.updateSummary();
          }
        }
        
        updateStepIndicators() {
          const indicators = document.querySelectorAll('.step-indicator-item');
          indicators.forEach((indicator, index) => {
            const step = index + 1;
            indicator.classList.toggle('active', step === this.currentStep);
            indicator.classList.toggle('completed', step < this.currentStep);
          });
        }
        
        updateButtonStates() {
          const prevBtn = document.getElementById('prev-btn');
          const nextBtn = document.getElementById('next-btn');
          const generateBtn = document.getElementById('stepwise-generation-btn');
          
          if (prevBtn) {
            prevBtn.disabled = this.currentStep === 1;
            prevBtn.style.opacity = this.currentStep === 1 ? '0.5' : '1';
          }
          
          if (this.currentStep === this.totalSteps) {
            if (nextBtn) {
              nextBtn.style.display = 'none';
            }
            if (generateBtn) {
              generateBtn.style.display = 'block';
              generateBtn.disabled = !this.validateAllSteps();
            }
          } else {
            if (nextBtn) {
              nextBtn.style.display = 'block';
              nextBtn.disabled = !this.validateCurrentStep();
            }
            if (generateBtn) {
              generateBtn.style.display = 'none';
            }
          }
        }
        
        validateAllSteps() {
          for (let i = 1; i <= this.totalSteps - 1; i++) {
            // Save current step, validate each step, then restore
            const originalStep = this.currentStep;
            this.currentStep = i;
            const isValid = this.validateCurrentStep();
            this.currentStep = originalStep;
            
            if (!isValid) return false;
          }
          return true;
        }
        
        updateSummary() {
          const summaryEl = document.getElementById('settings-summary');
          if (!summaryEl) return;
          
          const formData = this.collectFormData();
          const getDisplayValue = (value, options) => {
            const option = document.querySelector(`option[value="${value}"]`);
            return option ? option.textContent : value;
          };
          
          const summary = `
            <div class="summary-item">👥 <strong>参加人数:</strong> ${formData.participants}人</div>
            <div class="summary-item">⏰ <strong>時代背景:</strong> ${getDisplayValue(formData.era)}</div>
            <div class="summary-item">🏢 <strong>舞台設定:</strong> ${getDisplayValue(formData.setting)}</div>
            <div class="summary-item">🌍 <strong>世界観:</strong> ${getDisplayValue(formData.worldview)}</div>
            <div class="summary-item">🎭 <strong>トーン:</strong> ${getDisplayValue(formData.tone)}</div>
            <div class="summary-item">⚡ <strong>事件タイプ:</strong> ${getDisplayValue(formData.incident_type)}</div>
            <div class="summary-item">🧩 <strong>複雑さ:</strong> ${getDisplayValue(formData.complexity)}</div>
            ${formData.red_herring ? '<div class="summary-item">🎯 レッドヘリング: 有効</div>' : ''}
            ${formData.twist_ending ? '<div class="summary-item">🌪️ どんでん返し: 有効</div>' : ''}
            ${formData.secret_roles ? '<div class="summary-item">🎭 秘密の役割: 有効</div>' : ''}
          `;
          summaryEl.innerHTML = summary;
        }
        
        collectFormData() {
          const form = document.getElementById('scenario-form');
          const formData = new FormData(form);
          const data = {};
          
          // Get form field values
          for (const [key, value] of formData.entries()) {
            data[key] = value;
          }
          
          // Get checkbox values
          const checkboxes = ['red_herring', 'twist_ending', 'secret_roles'];
          checkboxes.forEach(name => {
            const checkbox = document.getElementById(name);
            data[name] = checkbox ? checkbox.checked : false;
          });
          
          return data;
        }
        
        saveFormData(field, value) {
          try {
            const saved = JSON.parse(localStorage.getItem('murder-mystery-form') || '{}');
            saved[field] = value;
            saved.lastUpdated = new Date().toISOString();
            localStorage.setItem('murder-mystery-form', JSON.stringify(saved));
          } catch (error) {
            console.warn('Failed to save form data:', error);
          }
        }
        
        restoreFormData() {
          try {
            const saved = JSON.parse(localStorage.getItem('murder-mystery-form') || '{}');
            for (const [field, value] of Object.entries(saved)) {
              if (field === 'lastUpdated') continue;
              
              const element = document.getElementById(field);
              if (element) {
                if (element.type === 'checkbox') {
                  element.checked = value;
                } else {
                  element.value = value;
                }
              }
            }
          } catch (error) {
            console.warn('Failed to restore form data:', error);
          }
        }
        
        async startUltraGeneration() {
          if (this.isGenerating) return;
          
          this.isGenerating = true;
          
          try {
            const formData = this.collectFormData();
            console.log('🚀 ULTRA: Starting quantum scenario generation:', formData);
            
            // UI transition with animation
            this.showUltraLoading();
            
            // Multi-phase progress tracking
            this.updateUltraProgress(5, '🚀 Groq量子エンジン起動中...', 'AI並列処理システム初期化', '予想時間: 45秒以内');
            
            // まずテストエンドポイントで接続確認
            console.log('🔍 Testing API connectivity...');
            const testResult = await apiClient.get('/test-simple');
            console.log('✅ API Test Result:', testResult);
            
            this.updateUltraProgress(15, '⚡ API接続確認完了...', 'Groq AIエンジン呼び出し開始', '残り35秒');
            
            // メイン生成API呼び出し
            const result = await apiClient.post('/groq-phase1-concept', formData);
            
            // APIの応答形式をチェック
            console.log('🔍 API Response Structure:', result);
            
            let success = false;
            let content = '';
            let metadata = {};
            
            // 複数の応答形式に対応
            if (result.data && result.data.success) {
              success = true;
              content = result.data.content;
              metadata = result.data;
            } else if (result.success) {
              success = true;
              content = result.content;
              metadata = result;
            } else if (result.status === 'SUCCESS' || result.message) {
              // テストエンドポイントからの成功応答
              success = true;
              content = `# 🎭 テストシナリオ生成成功!\n\n**API接続**: ✅ 正常\n**タイムスタンプ**: ${result.timestamp}\n**環境設定**: Groq/OpenAI API準備完了\n\n**次のステップ**: 本格的なAI生成を実行中...`;
              metadata = result;
            }
            
            if (success) {
              this.updateUltraProgress(70, '✅ メインシナリオ生成完了!', '追加コンテンツ生成中...', '残り15秒');
              
              // メインシナリオ表示
              this.displayUltraResult(content, metadata);
              
              // 追加コンテンツを並列生成
              setTimeout(async () => {
                try {
                  this.updateUltraProgress(80, '🎭 キャラクター・手がかり生成中...', '高品質コンテンツ作成中', '残り10秒');
                  await this.generateAdditionalContent();
                  this.updateUltraProgress(100, '🎉 全コンテンツ生成完了!', '準備完了 - PDFダウンロード可能', '');
                } catch (error) {
                  console.warn('Additional content generation failed, but main scenario is available:', error);
                  this.updateUltraProgress(100, '✅ メインシナリオ完了!', 'PDFダウンロード可能', '');
                }
              }, 1000);
            } else {
              throw new Error(result.error || result.data?.error || 'Generation failed');
            }
            
          } catch (error) {
            console.error('ULTRA Generation failed:', error);
            
            // エラーの詳細分析
            let errorMessage = 'シナリオ生成に失敗しました';
            let suggestion = '少し時間をおいて再試行してください';
            
            if (error.message) {
              if (error.message.includes('fetch')) {
                errorMessage = 'API接続エラーが発生しました';
                suggestion = 'インターネット接続を確認してください';
              } else if (error.message.includes('timeout')) {
                errorMessage = 'タイムアウトエラー';
                suggestion = 'サーバーが混雑している可能性があります。少し待ってから再試行してください';
              } else if (error.message.includes('401') || error.message.includes('403')) {
                errorMessage = 'API認証エラー';
                suggestion = 'システム管理者にお問い合わせください';
              } else if (error.message.includes('404')) {
                errorMessage = 'APIエンドポイントが見つかりません';
                suggestion = 'システムのデプロイメントに問題がある可能性があります';
              } else {
                errorMessage = `エラー: ${error.message}`;
              }
            }
            
            this.showUltraError(`${errorMessage}\n\n💡 ${suggestion}`);
          } finally {
            this.isGenerating = false;
          }
        }
        
        showUltraLoading() {
          document.getElementById('main-card').classList.add('hidden');
          document.getElementById('loading-indicator').classList.remove('hidden');
          
          // Enhanced loading animation
          const spinner = document.querySelector('.loading-spinner');
          if (spinner) {
            spinner.style.animation = 'spin 1s linear infinite';
          }
        }
        
        hideUltraLoading() {
          document.getElementById('loading-indicator').classList.add('hidden');
        }
        
        updateUltraProgress(percentage, phase, details, estimatedTime) {
          const progressFill = document.getElementById('progress-fill');
          const progressPercentage = document.getElementById('progress-percentage');
          const currentPhase = document.getElementById('current-phase');
          const phaseDetails = document.getElementById('phase-details');
          const estimatedTimeEl = document.getElementById('estimated-time');
          
          if (progressFill) {
            progressFill.style.width = percentage + '%';
            progressFill.style.boxShadow = `0 0 ${20 + percentage/5}px rgba(102, 126, 234, 0.${Math.min(80, 30 + percentage/2)})`;
          }
          if (progressPercentage) progressPercentage.textContent = percentage + '%';
          if (currentPhase) currentPhase.textContent = phase;
          if (phaseDetails) phaseDetails.textContent = details;
          if (estimatedTimeEl) estimatedTimeEl.textContent = estimatedTime;
        }
        
        displayUltraResult(content, metadata = {}) {
          this.hideUltraLoading();
          
          const resultContainer = document.getElementById('result-container');
          const scenarioContent = document.getElementById('scenario-content');
          
          if (scenarioContent) {
            // Enhanced content formatting
            const formattedContent = this.formatScenarioContent(content);
            scenarioContent.innerHTML = `
              <div class="ultra-result-header">
                <div class="generation-stats">
                  <span class="stat-item">📊 生成時間: ${metadata.processing_time || 'N/A'}</span>
                  <span class="stat-item">🤖 AI: ${metadata.provider || 'Groq'}</span>
                  <span class="stat-item">🚀 モデル: ${metadata.model || 'llama-3.1-8b-instant'}</span>
                </div>
              </div>
              <div class="ultra-content">${formattedContent}</div>
            `;
          }
          
          if (resultContainer) {
            resultContainer.classList.remove('hidden');
            resultContainer.style.display = 'block';
            
            // Smooth scroll to result
            setTimeout(() => {
              resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          }
          
          this.emit('generation:complete', { content, metadata });
        }
        
        formatScenarioContent(content) {
          return content
            .replace(/##\s(.+)/g, '<h3 class="text-2xl font-bold mt-6 mb-3 text-gradient">$1</h3>')
            .replace(/【(.+?)】/g, '<h4 class="text-lg font-bold mt-4 mb-2 text-indigo-600">【$1】</h4>')
            .replace(/^\d+\.\s(.+)/gm, '<li class="ml-6 mb-1 text-gray-700">$1</li>')
            .replace(/\n\n/g, '</p><p class="mb-4 text-gray-800 leading-relaxed">')
            .replace(/\n/g, '<br>');
        }
        
        showUltraError(message) {
          this.hideUltraLoading();
          
          const errorContainer = document.getElementById('error-container');
          const errorMessage = document.getElementById('error-message');
          
          if (errorMessage) {
            errorMessage.innerHTML = `
              <div class="ultra-error">
                <div class="error-icon">⚠️</div>
                <div class="error-text">${message}</div>
                <div class="error-suggestion">ネットワーク接続を確認して再試行してください。</div>
              </div>
            `;
          }
          
          if (errorContainer) {
            errorContainer.classList.remove('hidden');
          }
          
          this.emit('generation:error', { message });
        }
        
        hideError() {
          document.getElementById('error-container').classList.add('hidden');
        }
        
        resetToStart() {
          this.currentStep = 1;
          this.isGenerating = false;
          
          // Hide all containers
          document.getElementById('result-container').classList.add('hidden');
          document.getElementById('error-container').classList.add('hidden');
          document.getElementById('loading-indicator').classList.add('hidden');
          
          // Show main card
          document.getElementById('main-card').classList.remove('hidden');
          
          // Update display
          this.updateStepDisplay();
          
          // Scroll to top
          window.scrollTo({ top: 0, behavior: 'smooth' });
          
          this.emit('app:reset');
        }
        
        async generateAdditionalContent() {
          try {
            console.log('🚀 ULTRA: Starting enhanced content generation...');
            
            const scenarioContent = document.getElementById('scenario-content');
            if (!scenarioContent) {
              throw new Error('シナリオコンテンツが見つかりません');
            }
            
            const scenarioText = scenarioContent.innerText || scenarioContent.textContent;
            const formData = this.collectFormData();
            
            console.log('📝 Scenario text length:', scenarioText.length);
            console.log('🎯 Form data:', formData);
            
            // 各APIを個別に呼び出してエラーを特定しやすくする
            const additionalContent = {
              characters: [],
              relationships: [],
              clues: [],
              timeline: [],
              gamemaster: []
            };
            
            // キャラクター生成
            try {
              console.log('👥 Generating characters...');
              const charactersResult = await apiClient.post('/groq-phase2-characters', { 
                concept: scenarioText, 
                participants: formData.participants,
                era: formData.era,
                setting: formData.setting
              });
              console.log('✅ Characters API response:', charactersResult);
              additionalContent.characters = charactersResult.data?.content || charactersResult.data?.data || 'キャラクター生成に失敗しました';
            } catch (error) {
              console.warn('⚠️ Characters generation failed:', error);
              additionalContent.characters = 'キャラクター生成中にエラーが発生しました';
            }
            
            // 手がかり生成
            try {
              console.log('🔍 Generating clues...');
              const cluesResult = await apiClient.post('/groq-phase5-clues', { 
                concept: scenarioText, 
                participants: formData.participants 
              });
              console.log('✅ Clues API response:', cluesResult);
              additionalContent.clues = cluesResult.data?.content || cluesResult.data?.data || '手がかり生成に失敗しました';
            } catch (error) {
              console.warn('⚠️ Clues generation failed:', error);
              additionalContent.clues = '手がかり生成中にエラーが発生しました';
            }
            
            // タイムライン生成
            try {
              console.log('⏰ Generating timeline...');
              const timelineResult = await apiClient.post('/groq-phase6-timeline', { 
                concept: scenarioText, 
                participants: formData.participants 
              });
              console.log('✅ Timeline API response:', timelineResult);
              additionalContent.timeline = timelineResult.data?.content || timelineResult.data?.data || 'タイムライン生成に失敗しました';
            } catch (error) {
              console.warn('⚠️ Timeline generation failed:', error);
              additionalContent.timeline = 'タイムライン生成中にエラーが発生しました';
            }
            
            // ゲームマスターガイド生成
            try {
              console.log('🎮 Generating gamemaster guide...');
              const gmResult = await apiClient.post('/groq-phase8-gamemaster', { 
                concept: scenarioText, 
                participants: formData.participants 
              });
              console.log('✅ GM Guide API response:', gmResult);
              additionalContent.gamemaster = gmResult.data?.content || gmResult.data?.data || 'GMガイド生成に失敗しました';
            } catch (error) {
              console.warn('⚠️ GM Guide generation failed:', error);
              additionalContent.gamemaster = 'GMガイド生成中にエラーが発生しました';
            }
            
            this.additionalContent = additionalContent;
            console.log('✅ Enhanced additional content generated:', this.additionalContent);
            this.displayAdditionalContent();
            
          } catch (error) {
            console.error('❌ Additional content generation failed:', error);
            this.showError('追加コンテンツの生成に失敗しました: ' + error.message);
          }
        }
        
        displayAdditionalContent() {
          const container = document.getElementById('additional-content');
          if (!container) {
            console.error('❌ Additional content container not found');
            return;
          }
          
          console.log('🎨 Displaying additional content:', this.additionalContent);
          
          const formatContent = (content) => {
            if (!content) return '生成中...';
            if (typeof content === 'string') return content;
            if (Array.isArray(content)) return content.join('\n\n');
            return JSON.stringify(content, null, 2);
          };
          
          container.innerHTML = `
            <div class="additional-sections">
              <h3>🎭 生成された追加コンテンツ</h3>
              
              <div class="content-section">
                <h4>👥 詳細キャラクター設定</h4>
                <div class="content-text">${formatContent(this.additionalContent.characters)}</div>
              </div>
              
              <div class="content-section">
                <h4>🔍 証拠・手がかり</h4>
                <div class="content-text">${formatContent(this.additionalContent.clues)}</div>
              </div>
              
              <div class="content-section">
                <h4>⏰ 詳細タイムライン</h4>
                <div class="content-text">${formatContent(this.additionalContent.timeline)}</div>
              </div>
              
              <div class="content-section">
                <h4>🎮 ゲームマスター進行ガイド</h4>
                <div class="content-text">${formatContent(this.additionalContent.gamemaster)}</div>
              </div>
              
              <div class="content-section">
                <h4>📊 生成統計</h4>
                <div class="content-text">
                  キャラクター: ${this.additionalContent.characters ? '✅ 生成完了' : '❌ 失敗'}
                  手がかり: ${this.additionalContent.clues ? '✅ 生成完了' : '❌ 失敗'}
                  タイムライン: ${this.additionalContent.timeline ? '✅ 生成完了' : '❌ 失敗'}
                  GMガイド: ${this.additionalContent.gamemaster ? '✅ 生成完了' : '❌ 失敗'}
                </div>
              </div>
            </div>
          `;
          
          container.classList.remove('hidden');
          console.log('✅ Additional content displayed successfully');
        }

        async downloadPDF() {
          try {
            console.log('🖨️ Starting enhanced PDF generation...');
            
            const scenarioContent = document.getElementById('scenario-content');
            if (!scenarioContent) {
              throw new Error('シナリオコンテンツが見つかりません');
            }
            
            const scenarioText = scenarioContent.innerText || scenarioContent.textContent;
            const formData = this.collectFormData();
            
            // 追加コンテンツがない場合は生成
            if (!this.additionalContent) {
              console.log('🔄 Generating additional content for PDF...');
              await this.generateAdditionalContent();
            }
            
            const pdfData = {
              scenario: scenarioText,
              title: `🕵️ マーダーミステリー：${formData.participants}人用シナリオ`,
              characters: this.additionalContent?.characters || [],
              timeline: this.additionalContent?.timeline || [],
              handouts: this.additionalContent?.clues || []
            };
            
            console.log('📄 PDF data prepared:', pdfData);
            
            // PDF生成API呼び出し
            const result = await apiClient.post('/generate-pdf', pdfData);
            
            if (result.data && result.data.success && result.data.pdf) {
              // Base64 PDFをダウンロード
              const link = document.createElement('a');
              link.href = 'data:application/pdf;base64,' + result.data.pdf;
              link.download = `murder_mystery_scenario_${formData.participants}players_${new Date().toISOString().split('T')[0]}.pdf`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              
              console.log('✅ Enhanced PDF download completed');
              alert('🎉 高品質PDFのダウンロードが完了しました！');
            } else {
              throw new Error('PDF生成に失敗しました');
            }
            
          } catch (error) {
            console.error('❌ PDF download failed:', error);
            alert('PDFのダウンロードに失敗しました: ' + error.message);
          }
        }
        
        debounce(key, func, delay) {
          if (this.debounceMap.has(key)) {
            clearTimeout(this.debounceMap.get(key));
          }
          
          const timeoutId = setTimeout(() => {
            func();
            this.debounceMap.delete(key);
          }, delay);
          
          this.debounceMap.set(key, timeoutId);
        }
        
        destroy() {
          this.removeAllListeners();
          this.debounceMap.forEach(timeoutId => clearTimeout(timeoutId));
          this.debounceMap.clear();
        }
      }
      
      updateUltraProgress(70, '🎮 UIコントローラー構築中...', 'イベントリスナー + バリデーション設定');
      
      // INITIALIZE ULTRA UI
      const ultraUI = new UltraUIController();
      ultraUI.restoreFormData(); // Restore previous session
      ultraUI.updateStepDisplay();
      
      updateUltraProgress(85, '🔗 グローバル参照設定中...', 'モジュール間連携構築');
      
      // GLOBAL REFERENCES FOR DEBUGGING
      window.ultraUI = ultraUI;
      window.modules = modules;
      window.apiClient = apiClient;
      window.version = version;
      
      updateUltraProgress(95, '⚡ パフォーマンス最適化中...', 'メモリ使用量最適化 + GC調整');
      
      // PERFORMANCE OPTIMIZATION
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          if (entry.entryType === 'measure') {
            console.log(`🚀 Performance: ${entry.name} took ${entry.duration.toFixed(2)}ms`);
          }
        }
      });
      observer.observe({ entryTypes: ['measure'] });
      
      updateUltraProgress(100, '✅ 超高速初期化完了!', 'システム準備完了 - 最高性能で動作中');
      
      // FADE OUT OVERLAY WITH STYLE
      setTimeout(() => {
        overlay.style.transition = 'opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.remove();
          performance.mark('app-init-complete');
          performance.measure('app-initialization', 'navigationStart', 'app-init-complete');
        }, 800);
      }, 1000);
      
      console.log(`✅ ULTRA Murder Mystery Generator ${version} initialized successfully!`);
      console.log('🚀 ULTRA Features activated: Quantum UI, Real-time validation, Auto-save, Enhanced API');
      
      // HEALTH CHECK
      setTimeout(() => {
        if (apiClient && typeof apiClient.checkHealth === 'function') {
          apiClient.checkHealth();
        }
      }, 2000);
      
    } catch (error) {
      console.error('❌ ULTRA Initialization failed:', error);
      updateUltraProgress(0, '❌ エラー: ' + error.message, 'システム回復を試行中...');
      
      // FALLBACK SYSTEM
      setTimeout(() => {
        updateUltraProgress(50, '🔄 フォールバック システム起動中...', 'ベーシックモードで継続');
        setTimeout(() => {
          overlay.style.opacity = '0';
          setTimeout(() => overlay.remove(), 500);
        }, 1000);
      }, 2000);
    }
  </script>
  
  <!-- Enhanced fallback for browsers without ES6 module support -->
  <script nomodule>
    document.body.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100vh; font-family: Inter, sans-serif; text-align: center; background: linear-gradient(135deg, #667eea, #764ba2); color: white;"><div style="background: rgba(255,255,255,0.1); padding: 3rem; border-radius: 20px; backdrop-filter: blur(10px);"><div style="font-size: 4rem; margin-bottom: 1rem;">⚠️</div><h2 style="margin-bottom: 1rem; font-size: 1.8rem;">ブラウザが対応していません</h2><p style="font-size: 1.1rem; line-height: 1.6; margin-bottom: 2rem;">このULTRA EDITIONアプリケーションには<br>モダンなブラウザが必要です。</p><div style="background: rgba(255,255,255,0.2); padding: 1rem; border-radius: 10px; margin-bottom: 2rem;"><strong>推奨ブラウザ:</strong><br>Chrome 90+, Firefox 88+, Safari 14+, Edge 90+</div><button onclick="location.reload()" style="background: #667eea; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 1rem; cursor: pointer; transition: background 0.3s;">再読み込み</button></div></div>';
  </script>
  
  <!-- 新しいモジュラーアプリケーションの読み込み -->
  <script type="module">
    // 新しいMurderMysteryApp.jsの読み込みと初期化
    import { default as MurderMysteryApp } from './js/MurderMysteryApp.js';
    
    // アプリケーション初期化
    window.addEventListener('DOMContentLoaded', () => {
      try {
        console.log('🚀 Initializing new MurderMysteryApp...');
        const app = new MurderMysteryApp();
        window.murderMysteryApp = app; // デバッグ用のグローバル参照
        console.log('✅ New MurderMysteryApp initialized successfully!');
      } catch (error) {
        console.error('❌ Failed to initialize MurderMysteryApp:', error);
      }
    });
  </script>

  <!-- エラーハンドリング - 最小限 -->
  <script>
    // グローバルエラー処理 - ブラウザ拡張の警告を無視
    window.addEventListener('error', (e) => {
      if (e.message && (
        e.message.includes('runtime.lastError') ||
        e.message.includes('Extension context') ||
        e.message.includes('message port closed')
      )) {
        e.preventDefault();
        return false;
      }
    });
    
    window.addEventListener('unhandledrejection', (e) => {
      console.error('Promise rejection:', e.reason);
    });
  </script>
</body>
</html>